'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _makeCancelable = require('./makeCancelable');

var _makeCancelable2 = _interopRequireDefault(_makeCancelable);

var _flushPromises = require('./flushPromises');

var _flushPromises2 = _interopRequireDefault(_flushPromises);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('makeCancelable', function () {
  it('should return a function', function () {
    var promise = Promise.resolve();
    var cancel = (0, _makeCancelable2.default)(promise);
    expect(typeof cancel === 'undefined' ? 'undefined' : _typeof(cancel)).toBe('function');
  });

  it('calls @onfulfilled with the same value as resolved @promise', function () {
    var obj = Object();
    var promise = Promise.resolve(obj);
    var onfulfilled = _sinon2.default.spy();
    (0, _makeCancelable2.default)(promise, onfulfilled);
    return (0, _flushPromises2.default)().then(function () {
      return expect(onfulfilled.calledWith(obj)).toBe(true);
    });
  });

  it('calls @onrejected with the same value @promise to be rejected', function () {
    var obj = Object();
    var promise = Promise.reject(obj);
    var onrejected = _sinon2.default.spy();
    (0, _makeCancelable2.default)(promise, null, onrejected);
    return (0, _flushPromises2.default)().then(function () {
      return expect(onrejected.calledWith(obj)).toBe(true);
    });
  });

  it('should not call @onfulfilled\n      when cancelled on @promise to be resolved', function () {
    var obj = Object();
    var promise = Promise.resolve(obj);
    var onfulfilled = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, onfulfilled);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      return expect(onfulfilled.notCalled).toBe(true);
    });
  });

  it('should not call @onrejected\n      when cancelled on @promise to be resolved', function () {
    var obj = Object();
    var promise = Promise.resolve(obj);
    var onrejected = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, null, onrejected);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      return expect(onrejected.notCalled).toBe(true);
    });
  });

  it('should not call @onrejected and @onrejected\n      when cancelled on @promise to be resolved', function () {
    var obj = Object();
    var promise = Promise.resolve(obj);
    var onrejected = _sinon2.default.spy();
    var onfulfilled = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, onfulfilled, onrejected);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      expect(onrejected.notCalled).toBe(true);
      expect(onfulfilled.notCalled).toBe(true);
    });
  });

  it('should not call @onfulfilled\n      when cancelled on @promise to be rejected', function () {
    var obj = Object();
    var promise = Promise.reject(obj);
    var onfulfilled = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, onfulfilled);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      return expect(onfulfilled.notCalled).toBe(true);
    });
  });

  it('should not call @onrejected\n      when cancelled on @promise to be rejected', function () {
    var obj = Object();
    var promise = Promise.reject(obj);
    var onrejected = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, null, onrejected);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      return expect(onrejected.notCalled).toBe(true);
    });
  });

  it('should not call @onrejected and @onrejected\n      when cancelled on @promise to be rejected', function () {
    var obj = Object();
    var promise = Promise.reject(obj);
    var onrejected = _sinon2.default.spy();
    var onfulfilled = _sinon2.default.spy();
    var cancel = (0, _makeCancelable2.default)(promise, onfulfilled, onrejected);
    cancel();
    return (0, _flushPromises2.default)().then(function () {
      expect(onrejected.notCalled).toBe(true);
      expect(onfulfilled.notCalled).toBe(true);
    });
  });
});